include("./lazywarehouse.jl")
include("./collisionchecker.jl")
include("./WarehouseGrapher.jl")

# define global constants for organizing the route array
jobcount = 3
vehiclecount = 2

u = jobcount + vehiclecount

# Initialise A* for a given map
x = 16;
y = 16;
g, dist_mat = path_init("SmallWarehouseMap.csv", x, y);

# TODO I haven't checked whether these indices represent valid locations.
jobs = [Dict("job_id" => 1,
             "start_node" => 22,
             "end_node" => 26),
        Dict("job_id" => 2,
             "start_node" => 100,
             "end_node" => 200),
        Dict("job_id" => 3,
             "start_node" => 150,
             "end_node" => 101)];

vehicles = [Dict("vehicle_id" => 1,
             "start_node" => 23),
        Dict("vehicle_id" => 2,
             "start_node" => 239)];

routecosts = Array(Int,u,u)
# generated by pathcost module

routedefinitions = Array(Any,u,u)
# generated by A*

# TODO nodecosts; is this just the dist_mat we generated for A*? Wrong dimensions if so.
nodecosts = Array(Int,x*y)
# generated from map
# 1 dim array nodecosts[1] = cost to traverse node1
# TODO Cost to traverse node1 relative to what? Cost is different if cornering/diagonal/straight movement.

for (v_index, vehicle) in enumerate(vehicles)

    # Calculate vehicle to vehicle costs
    current_index = 1;
    for (v_other_index, vehicle_other) in enumerate(vehicles)
        route = path_main(vehicle["start_node"], vehicle_other["start_node"], g, dist_mat);
        cost_vehicle_start_to_job_start = calc_path_cost(route, dist_mat);
        routecosts[v_index, current_index] = cost_vehicle_start_to_job_start;
        current_index += 1;
    end

    current_index -= 1; # TODO Comment

    for (j_index, job) in enumerate(jobs)
        route = path_main(vehicle["start_node"], job["start_node"], g, dist_mat);

        cost_vehicle_start_to_job_start = calc_path_cost(route, dist_mat);
        routecosts[v_index, current_index + j_index] = cost_vehicle_start_to_job_start;
        #println(route);
        # TODO Add this to the array somehow
    end
end

for (j_index, job) in enumerate(jobs)

    # Calculate job to vehicle costs
    current_index = 1;
    for (v_index, vehicle) in enumerate(vehicles)
        route = path_main(job["end_node"], vehicle["start_node"], g, dist_mat);
        cost_vehicle_start_to_job_start = calc_path_cost(route, dist_mat);
        routecosts[j_index + size(vehicles)[1], current_index] = cost_vehicle_start_to_job_start;
        current_index += 1;
    end

    current_index -= 1; # TODO Comment

    for (j_other_index, job_other) in enumerate(jobs)
        route = path_main(job["end_node"], job_other["start_node"], g, dist_mat);

        cost_vehicle_start_to_job_start = calc_path_cost(route, dist_mat);
        routecosts[j_index + size(vehicles)[1], current_index + j_other_index] = cost_vehicle_start_to_job_start;
        #println(route);
        # TODO Add this to the array somehow
    end
end


println(routecosts)


#=
for job in jobs
    route = path_main(job["start_node"], job["end_node"], g, dist_mat);
    cost = calc_path_cost(route, dist_mat);
    routecosts[]
    # routecosts TODO Add the cost to the routecosts array somehow. How do we get the 'cost' of this route?
    # TODO Store the actual route as well
end
=#

routeplan = planroutes(routecosts, jobcount, vehiclecount)
println("Printing route plan");
println(routeplan);

routeplots = plotroutes(vehiclecount, routeplan, routedefinitions)

println("Printing route plots");
println(routeplots);

animatedroutes = animateroutes(routeplots, nodecosts)
resolvedroutes = resolvecollisions(animatedroutes)
